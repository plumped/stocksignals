<!-- stock_analyzer/templates/stock_analyzer/stock_detail.html -->
{% extends 'stock_analyzer/base.html' %}
{% load math_filters %}




{% block title %}{{ stock.symbol }} - {{ stock.name }}{% endblock %}

{% block extra_head %}
<style>
    .indicator-card {
        height: 100%;
    }
    .signal-buy {
        color: green;
        font-weight: bold;
    }
    .signal-sell {
        color: red;
        font-weight: bold;
    }
    .signal-neutral {
        color: orange;
        font-weight: bold;
    }
</style>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Chart.js Annotation Plugin -->
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

<script src="https://cdn.jsdelivr.net/npm/luxon"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>


{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <div>
        <h2>{{ stock.symbol }} - {{ stock.name }}</h2>
        {% if stock.sector %}<p>Sektor: {{ stock.sector }}</p>{% endif %}
    </div>
    <div>
        {% if latest_analysis %}
        <div class="d-flex align-items-center">
            <span class="me-2">Score:</span>
            <div class="progress" style="width: 200px;">
                {% if latest_analysis.technical_score >= 70 %}
                    <div class="progress-bar bg-success" style="width: {{ latest_analysis.technical_score }}%">{{ latest_analysis.technical_score }}</div>
                {% elif latest_analysis.technical_score <= 30 %}
                    <div class="progress-bar bg-danger" style="width: {{ latest_analysis.technical_score }}%">{{ latest_analysis.technical_score }}</div>
                {% else %}
                    <div class="progress-bar bg-warning" style="width: {{ latest_analysis.technical_score }}%">{{ latest_analysis.technical_score }}</div>
                {% endif %}
            </div>
        </div>
        <div class="d-flex align-items-center mt-2">
            <span class="me-2">Confluence:</span>
            <div class="progress" style="width: 200px;">
                {% if latest_analysis.confluence_score is not None %}
                    {% with score=latest_analysis.confluence_score|floatformat:0 %}
                        {% if score|add:'0' >= 8 %}
                            <div class="progress-bar bg-success" style="width: {{ score|mul:10 }}%;">
                                {{ score }}/10
                            </div>
                        {% elif score|add:'0' >= 4 %}
                            <div class="progress-bar bg-warning" style="width: {{ score|mul:10 }}%;">
                                {{ score }}/10
                            </div>
                        {% else %}
                            <div class="progress-bar bg-danger" style="width: {{ score|mul:10 }}%;">
                                {{ score }}/10
                            </div>
                        {% endif %}
                    {% endwith %}
                {% else %}
                    <div class="progress-bar bg-secondary" style="width: 100%;">Keine Daten</div>
                {% endif %}
            </div>
        </div>

        <div class="mt-2">
            {% if latest_analysis.recommendation == 'BUY' %}
                <span class="badge bg-success fs-6">KAUFEN</span>
            {% elif latest_analysis.recommendation == 'SELL' %}
                <span class="badge bg-danger fs-6">VERKAUFEN</span>
            {% else %}
                <span class="badge bg-warning fs-6">HALTEN</span>
            {% endif %}
            <small class="text-muted ms-2">Letzte Analyse: {{ latest_analysis.date }}</small>
        </div>
        {% endif %}
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Kursverlauf</span>
                <div class="btn-group btn-group-sm">
                    <button type="button" class="btn btn-outline-secondary time-range" data-range="30">1M</button>
                    <button type="button" class="btn btn-outline-secondary time-range" data-range="90">3M</button>
                    <button type="button" class="btn btn-outline-secondary time-range active" data-range="180">6M</button>
                    <button type="button" class="btn btn-outline-secondary time-range" data-range="365">1J</button>
                </div>
            </div>
            <div class="card-body">
                <canvas id="price-chart" height="350"></canvas>
            </div>
        </div>
    </div>

    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                Aktionen
            </div>
            <div class="card-body">
                <div id="current-price-container" class="alert alert-info mb-2" style="display: none;">
                    <strong>Aktueller Kurs:</strong> <span id="current-price-value"></span>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="use-live-data" {% if use_live_data %}checked{% endif %}>
                    <label class="form-check-label" for="use-live-data">
                        Live-Daten verwenden (statt Schlusskurse)
                    </label>
                </div>
                <button id="analyze-button" class="btn btn-primary mb-3 w-100">
                    <i class="bi bi-graph-up"></i> Jetzt analysieren
                </button>

                <!-- ML Backtesting Section -->
                <div class="mb-3">
                    <a href="{% url 'ml_backtest' stock.symbol %}" class="btn btn-outline-info mb-2 w-100">
                        <i class="bi bi-robot"></i> ML Backtest
                    </a>

                    <a href="{% url 'ml_strategy_comparison' stock.symbol %}" class="btn btn-outline-info mb-2 w-100">
                        <i class="bi bi-gear-wide-connected"></i> ML Strategievergleich
                    </a>
                </div>

                {% if user.is_authenticated %}
                    {% if in_watchlist %}
                    <button id="remove-watchlist" class="btn btn-outline-danger mb-3 w-100">
                        <i class="bi bi-star-fill"></i> Von Watchlist entfernen
                    </button>
                    {% else %}
                    <div class="dropdown mb-3 w-100">
                        <button class="btn btn-outline-primary dropdown-toggle w-100" type="button" id="watchlistDropdown" data-bs-toggle="dropdown">
                            <i class="bi bi-star"></i> Zur Watchlist hinzufügen
                        </button>
                        <ul class="dropdown-menu w-100" aria-labelledby="watchlistDropdown">
                            <!-- Liste der Watchlists hier -->
                            <li><a class="dropdown-item" href="#">Neue Watchlist erstellen...</a></li>
                        </ul>
                    </div>
                    {% endif %}
                {% endif %}

                <a href="https://finance.yahoo.com/quote/{{ stock.symbol }}" target="_blank" class="btn btn-outline-secondary w-100">
                    <i class="bi bi-box-arrow-up-right"></i> Yahoo Finance
                </a>
            </div>
        </div>

        <div class="card mt-3">
            <div class="card-header">
                Hauptindikatoren
            </div>
            <div class="card-body">
                <table class="table table-sm" id="main-indicators-table">
                    <tbody>
                        {% if latest_analysis %}
                        <tr>
                            <td>RSI (14)</td>
                            <td class="text-end">
                                <span id="indicator-rsi">{{ latest_analysis.rsi_value|floatformat:2 }}</span>
                                <span id="indicator-rsi-signal" class="{% if latest_analysis.rsi_value < 30 %}signal-buy{% elif latest_analysis.rsi_value > 70 %}signal-sell{% endif %}">
                                    {% if latest_analysis.rsi_value < 30 %}
                                    <i class="bi bi-arrow-up-circle-fill"></i>
                                    {% elif latest_analysis.rsi_value > 70 %}
                                    <i class="bi bi-arrow-down-circle-fill"></i>
                                    {% endif %}
                                </span>
                            </td>
                        </tr>
                        <tr>
                            <td>MACD</td>
                            <td class="text-end">
                                <span id="indicator-macd">{{ latest_analysis.macd_value|floatformat:2 }}</span>
                                <span id="indicator-macd-signal" class="{% if latest_analysis.macd_value > latest_analysis.macd_signal %}signal-buy{% else %}signal-sell{% endif %}">
                                    {% if latest_analysis.macd_value > latest_analysis.macd_signal %}
                                    <i class="bi bi-arrow-up-circle-fill"></i>
                                    {% else %}
                                    <i class="bi bi-arrow-down-circle-fill"></i>
                                    {% endif %}
                                </span>
                            </td>
                        </tr>
                        <tr>
                            <td>SMA 20</td>
                            <td class="text-end"><span id="indicator-sma20">{{ latest_analysis.sma_20|floatformat:2 }}</span></td>
                        </tr>
                        <tr>
                            <td>SMA 50</td>
                            <td class="text-end"><span id="indicator-sma50">{{ latest_analysis.sma_50|floatformat:2 }}</span></td>
                        </tr>
                        <tr>
                            <td>SMA 200</td>
                            <td class="text-end"><span id="indicator-sma200">{{ latest_analysis.sma_200|floatformat:2 }}</span></td>
                        </tr>
                        <tr>
                            <td>Bollinger Bands</td>
                            <td class="text-end">
                                <span id="indicator-bollinger-upper">{{ latest_analysis.bollinger_upper|floatformat:2 }}</span> /
                                <span id="indicator-bollinger-lower">{{ latest_analysis.bollinger_lower|floatformat:2 }}</span>
                            </td>
                        </tr>
                        {% else %}
                        <tr>
                            <td colspan="2" class="text-center">Keine Analysedaten verfügbar</td>
                        </tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-12">
        <ul class="nav nav-tabs" id="indicatorTabs">
            <li class="nav-item">
                <a class="nav-link active" id="momentum-tab" data-bs-toggle="tab" href="#momentum">Momentum</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="trend-tab" data-bs-toggle="tab" href="#trend">Trend</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="volatility-tab" data-bs-toggle="tab" href="#volatility">Volatilität</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="volume-tab" data-bs-toggle="tab" href="#volume">Volumen</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="historical-tab" data-bs-toggle="tab" href="#historical">Historische Daten</a>
            </li>
        </ul>

        <div class="tab-content mt-3" id="indicatorTabsContent">
            <div class="tab-pane fade show active" id="momentum">
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">RSI (Relative Strength Index)</div>
                            <div class="card-body">
                                <canvas id="rsi-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Stochastik Oszillator</div>
                            <div class="card-body">
                                <canvas id="stochastic-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <!-- Fortsetzung von stock_analyzer/templates/stock_analyzer/stock_detail.html -->
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">MACD (Moving Average Convergence Divergence)</div>
                            <div class="card-body">
                                <canvas id="macd-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Rate of Change (ROC)</div>
                            <div class="card-body">
                                <canvas id="roc-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="trend">
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Moving Averages (SMA)</div>
                            <div class="card-body">
                                <canvas id="sma-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Ichimoku Cloud</div>
                            <div class="card-body">
                                <canvas id="ichimoku-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">ADX (Average Directional Index)</div>
                            <div class="card-body">
                                <canvas id="adx-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">PSAR (Parabolic Stop and Reverse)</div>
                            <div class="card-body">
                                <canvas id="psar-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="volatility">
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Bollinger Bands</div>
                            <div class="card-body">
                                <canvas id="bollinger-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">ATR (Average True Range)</div>
                            <div class="card-body">
                                <canvas id="atr-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="volume">
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">OBV (On-Balance Volume)</div>
                            <div class="card-body">
                                <canvas id="obv-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card indicator-card">
                            <div class="card-header">Volume</div>
                            <div class="card-body">
                                <canvas id="volume-chart" height="250"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="historical">
                <div class="card">
                    <div class="card-header">Historische Daten</div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>Datum</th>
                                        <th>Eröffnung</th>
                                        <th>Hoch</th>
                                        <th>Tief</th>
                                        <th>Schluss</th>
                                        <th>Volumen</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for data in historical_data %}
                                    <tr>
                                        <td>{{ data.date }}</td>
                                        <td>{{ data.open_price }}</td>
                                        <td>{{ data.high_price }}</td>
                                        <td>{{ data.low_price }}</td>
                                        <td>{{ data.close_price }}</td>
                                        <td>{{ data.volume }}</td>
                                    </tr>
                                    {% empty %}
                                    <tr>
                                        <td colspan="6" class="text-center">Keine historischen Daten verfügbar</td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            {% include 'stock_analyzer/ml_prediction_card.html' with ml_prediction=ml_prediction %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
    const symbol = document.querySelector('h2').textContent.split(' - ')[0].trim();
    let stockData = null;
    let priceChart = null;
    let rsiChart = null;
    let macdChart = null;
    let stochasticChart = null;
    let smaChart = null;
    let bollingerChart = null;
    let volumeChart = null;
    let obvChart = null;
    let atrChart = null;

    // Tabs konfigurieren
    document.querySelectorAll('.time-range').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.time-range').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            updateCharts(parseInt(this.dataset.range));
        });
    });

    // Aktie analysieren
    const analyzeButton = document.getElementById('analyze-button');
    if (analyzeButton) {
        analyzeButton.addEventListener('click', function() {
            this.disabled = true;
            this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Analysiere...';

            // Prüfen, ob Live-Daten verwendet werden sollen
            const useLiveData = document.getElementById('use-live-data').checked;

            // URL mit Parameter für Live-Daten
            const url = `/analyze/${symbol}/?use_live_data=${useLiveData}`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Seite neu laden, um die aktualisierten Ergebnisse anzuzeigen
                        window.location.reload();
                    } else {
                        alert(`Fehler: ${data.message || 'Konnte Aktie nicht analysieren'}`);
                        this.disabled = false;
                        this.innerHTML = '<i class="bi bi-graph-up"></i> Jetzt analysieren';
                    }
                })
                .catch(error => {
                    alert(`Fehler: ${error.message}`);
                    this.disabled = false;
                    this.innerHTML = '<i class="bi bi-graph-up"></i> Jetzt analysieren';
                });
        });
    }

    // Watchlist Funktionalität
    const removeWatchlistBtn = document.getElementById('remove-watchlist');
    if (removeWatchlistBtn) {
        removeWatchlistBtn.addEventListener('click', function() {
            // Logik zum Entfernen aus der Watchlist implementieren
            // Hier müsste ein API-Aufruf erfolgen
        });
    }

    // Daten laden und Charts initialisieren
    function loadChartData() {
        // Prüfen, ob Live-Daten verwendet werden sollen
        const useLiveData = document.getElementById('use-live-data').checked;

        // URL mit Parameter für Live-Daten
        const url = `/api/stock/${symbol}/?use_live_data=${useLiveData}`;

        return fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Netzwerkantwort war nicht ok');
                }
                return response.json();
            });
    }

    // Funktion zum Anzeigen des aktuellen Preises
    function updateCurrentPrice(data) {
        const currentPriceContainer = document.getElementById('current-price-container');
        const currentPriceValue = document.getElementById('current-price-value');

        if (data.current_price) {
            currentPriceValue.textContent = `$${data.current_price.toFixed(2)}`;
            currentPriceContainer.style.display = 'block';

            // Wenn es historische Daten gibt, den letzten Schlusskurs anzeigen
            if (data.price_data && data.price_data.length > 0) {
                const lastClosePrice = data.price_data[0].close_price;
                const priceDiff = data.current_price - lastClosePrice;
                const priceDiffPercent = (priceDiff / lastClosePrice) * 100;

                // Farbliche Markierung basierend auf der Preisänderung
                if (priceDiff > 0) {
                    currentPriceValue.classList.add('text-success');
                    currentPriceValue.classList.remove('text-danger');
                    currentPriceValue.textContent += ` (+${priceDiff.toFixed(2)}, +${priceDiffPercent.toFixed(2)}%)`;
                } else if (priceDiff < 0) {
                    currentPriceValue.classList.add('text-danger');
                    currentPriceValue.classList.remove('text-success');
                    currentPriceValue.textContent += ` (${priceDiff.toFixed(2)}, ${priceDiffPercent.toFixed(2)}%)`;
                }
            }
        } else {
            currentPriceContainer.style.display = 'none';
        }
    }

    // Funktion zum Aktualisieren der Hauptindikatoren
    function updateMainIndicators(data) {
        if (!data || !data.indicators) return;

        console.log('Aktualisiere Hauptindikatoren mit Live-Daten');

        // Letzte Werte der Indikatoren abrufen
        const getLastValue = (indicator) => {
            if (!data.indicators[indicator] || data.indicators[indicator].length === 0) return null;
            const value = data.indicators[indicator][data.indicators[indicator].length - 1];
            console.log(`Indikator ${indicator}: Länge=${data.indicators[indicator].length}, letzter Wert=${value}`);
            return value;
        };

        // RSI aktualisieren
        const rsiValue = getLastValue('rsi');
        if (rsiValue !== null) {
            console.log('RSI Wert aus API:', rsiValue);
            const rsiElement = document.getElementById('indicator-rsi');
            const rsiSignalElement = document.getElementById('indicator-rsi-signal');

            rsiElement.textContent = rsiValue.toFixed(2);
            console.log('RSI Wert in UI aktualisiert:', rsiValue.toFixed(2));

            // RSI Signal aktualisieren
            rsiSignalElement.className = '';
            rsiSignalElement.innerHTML = '';

            if (rsiValue < 30) {
                rsiSignalElement.className = 'signal-buy';
                rsiSignalElement.innerHTML = '<i class="bi bi-arrow-up-circle-fill"></i>';
            } else if (rsiValue > 70) {
                rsiSignalElement.className = 'signal-sell';
                rsiSignalElement.innerHTML = '<i class="bi bi-arrow-down-circle-fill"></i>';
            }
        }

        // MACD aktualisieren
        const macdValue = getLastValue('macd');
        const macdSignalValue = getLastValue('macd_signal');

        if (macdValue !== null && macdSignalValue !== null) {
            const macdElement = document.getElementById('indicator-macd');
            const macdSignalElement = document.getElementById('indicator-macd-signal');

            macdElement.textContent = macdValue.toFixed(2);

            // MACD Signal aktualisieren
            macdSignalElement.className = '';
            macdSignalElement.innerHTML = '';

            if (macdValue > macdSignalValue) {
                macdSignalElement.className = 'signal-buy';
                macdSignalElement.innerHTML = '<i class="bi bi-arrow-up-circle-fill"></i>';
            } else {
                macdSignalElement.className = 'signal-sell';
                macdSignalElement.innerHTML = '<i class="bi bi-arrow-down-circle-fill"></i>';
            }
        }

        // SMAs aktualisieren
        const sma20Value = getLastValue('sma_20');
        const sma50Value = getLastValue('sma_50');
        const sma200Value = getLastValue('sma_200');

        if (sma20Value !== null) {
            document.getElementById('indicator-sma20').textContent = sma20Value.toFixed(2);
        }

        if (sma50Value !== null) {
            document.getElementById('indicator-sma50').textContent = sma50Value.toFixed(2);
        }

        if (sma200Value !== null) {
            document.getElementById('indicator-sma200').textContent = sma200Value.toFixed(2);
        }

        // Bollinger Bands aktualisieren
        const bollingerUpperValue = getLastValue('bollinger_upper');
        const bollingerLowerValue = getLastValue('bollinger_lower');

        if (bollingerUpperValue !== null) {
            document.getElementById('indicator-bollinger-upper').textContent = bollingerUpperValue.toFixed(2);
        }

        if (bollingerLowerValue !== null) {
            document.getElementById('indicator-bollinger-lower').textContent = bollingerLowerValue.toFixed(2);
        }
    }

    // Event-Listener für die Live-Daten-Checkbox
    document.getElementById('use-live-data').addEventListener('change', function() {
        // Charts neu laden, wenn die Checkbox geändert wird
        loadChartData()
            .then(data => {
                stockData = data;
                console.log('Daten neu geladen:', stockData);

                // Aktuellen Preis anzeigen, wenn Live-Daten aktiviert sind
                if (this.checked) {
                    updateCurrentPrice(data);
                    // Hauptindikatoren mit Live-Daten aktualisieren
                    updateMainIndicators(data);
                } else {
                    document.getElementById('current-price-container').style.display = 'none';
                }

                // Bestehende Charts löschen
                if (priceChart) priceChart.destroy();
                if (rsiChart) rsiChart.destroy();
                if (macdChart) macdChart.destroy();
                if (stochasticChart) stochasticChart.destroy();
                if (smaChart) smaChart.destroy();
                if (bollingerChart) bollingerChart.destroy();
                if (volumeChart) volumeChart.destroy();
                if (obvChart) obvChart.destroy();
                if (atrChart) atrChart.destroy();
                // Charts neu initialisieren
                initCharts();
                // Aktiven Zeitraum beibehalten
                const activeRange = document.querySelector('.time-range.active').dataset.range;
                updateCharts(parseInt(activeRange));
            })
            .catch(error => {
                console.error('Fehler beim Neuladen der Aktiendaten:', error);
            });
    });

    // Initial data load
    loadChartData()
        .then(data => {
            stockData = data;
            console.log('Geladene Daten:', stockData);

            // Aktuellen Preis und Hauptindikatoren anzeigen, wenn Live-Daten aktiviert sind
            if (document.getElementById('use-live-data').checked) {
                updateCurrentPrice(data);
                updateMainIndicators(data);
                console.log('Live-Daten beim initialen Laden aktiviert - Indikatoren aktualisiert');
            }

            initCharts();
            updateCharts(180); // Standardmäßig 6 Monate anzeigen
        })
        .catch(error => {
            console.error('Fehler beim Laden der Aktiendaten:', error);
        });

    function initCharts() {
        // Überprüfen, ob Daten vorhanden sind
        if (!stockData || !stockData.price_data || stockData.price_data.length === 0) {
            console.error('Keine Daten zum Initialisieren der Charts verfügbar');
            return;
        }

        // Überprüfe, ob die Daten in der richtigen Reihenfolge sind (neueste zuerst)
        let dataOrdered = true;
        try {
            const firstDate = new Date(stockData.price_data[0].date);
            const lastDate = new Date(stockData.price_data[stockData.price_data.length - 1].date);
            dataOrdered = firstDate > lastDate;
        } catch (e) {
            console.warn('Fehler beim Überprüfen der Datenreihenfolge:', e);
        }

        // Kurschart (Linienchart)
        const priceCtx = document.getElementById('price-chart');
        if (priceCtx) {
            priceChart = new Chart(priceCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Schlusskurs',
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        fill: true,
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            },
                            title: {
                                display: true,
                                text: 'Datum'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Preis'
                            }
                        }
                    }
                }
            });
        }

        // RSI-Chart initialisieren
        const rsiCtx = document.getElementById('rsi-chart');
        if (rsiCtx) {
            rsiChart = new Chart(rsiCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'RSI (14)',
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        fill: false,
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        },
                        y: {
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 10
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                overbought: {
                                    type: 'line',
                                    yMin: 70,
                                    yMax: 70,
                                    borderColor: 'red',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                oversold: {
                                    type: 'line',
                                    yMin: 30,
                                    yMax: 30,
                                    borderColor: 'green',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    }
                }
            });
        }

        // MACD-Chart initialisieren
        const macdCtx = document.getElementById('macd-chart');
        if (macdCtx) {
            macdChart = new Chart(macdCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'MACD Histogram',
                            type: 'bar',
                            backgroundColor: function(context) {
                                if (!context.raw) return 'rgba(0, 0, 0, 0)';
                                return context.raw.y < 0 ? 'rgba(255, 99, 132, 0.7)' : 'rgba(75, 192, 192, 0.7)';
                            },
                            order: 3,
                            data: []
                        },
                        {
                            label: 'MACD',
                            type: 'line',
                            borderColor: 'rgb(54, 162, 235)',
                            fill: false,
                            order: 1,
                            data: []
                        },
                        {
                            label: 'Signal',
                            type: 'line',
                            borderColor: 'rgb(255, 159, 64)',
                            fill: false,
                            order: 2,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }

        // Stochastic Chart
        const stochasticCtx = document.getElementById('stochastic-chart');
        if (stochasticCtx) {
            stochasticChart = new Chart(stochasticCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Stochastic %K',
                            borderColor: 'rgb(54, 162, 235)',
                            fill: false,
                            data: []
                        },
                        {
                            label: 'Stochastic %D',
                            borderColor: 'rgb(255, 159, 64)',
                            fill: false,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        },
                        y: {
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                overbought: {
                                    type: 'line',
                                    yMin: 80,
                                    yMax: 80,
                                    borderColor: 'red',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                },
                                oversold: {
                                    type: 'line',
                                    yMin: 20,
                                    yMax: 20,
                                    borderColor: 'green',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    }
                }
            });
        }

        // SMA Chart
        const smaCtx = document.getElementById('sma-chart');
        if (smaCtx) {
            smaChart = new Chart(smaCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Preis',
                            borderColor: 'rgb(0, 0, 0)',
                            fill: false,
                            order: 1,
                            data: []
                        },
                        {
                            label: 'SMA 20',
                            borderColor: 'rgb(54, 162, 235)',
                            fill: false,
                            order: 2,
                            data: []
                        },
                        {
                            label: 'SMA 50',
                            borderColor: 'rgb(255, 159, 64)',
                            fill: false,
                            order: 3,
                            data: []
                        },
                        {
                            label: 'SMA 200',
                            borderColor: 'rgb(255, 99, 132)',
                            fill: false,
                            order: 4,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }

        // Bollinger Bands Chart
        const bollingerCtx = document.getElementById('bollinger-chart');
        if (bollingerCtx) {
            bollingerChart = new Chart(bollingerCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Preis',
                            borderColor: 'rgb(0, 0, 0)',
                            fill: false,
                            order: 1,
                            data: []
                        },
                        {
                            label: 'SMA 20',
                            borderColor: 'rgb(54, 162, 235)',
                            fill: false,
                            order: 2,
                            data: []
                        },
                        {
                            label: 'Oberes Band',
                            borderColor: 'rgba(255, 99, 132, 0.7)',
                            fill: false,
                            order: 3,
                            data: []
                        },
                        {
                            label: 'Unteres Band',
                            borderColor: 'rgba(75, 192, 192, 0.7)',
                            fill: false,
                            order: 4,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }

        // Volume Chart
        const volumeCtx = document.getElementById('volume-chart');
        if (volumeCtx) {
            volumeChart = new Chart(volumeCtx.getContext('2d'), {
                type: 'bar',
                data: {
                    datasets: [
                        {
                            label: 'Volumen',
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }

        // OBV Chart
        const obvCtx = document.getElementById('obv-chart');
        if (obvCtx) {
            obvChart = new Chart(obvCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'On-Balance Volume',
                            borderColor: 'rgb(75, 192, 192)',
                            fill: false,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }

        // ATR Chart
        const atrCtx = document.getElementById('atr-chart');
        if (atrCtx) {
            atrChart = new Chart(atrCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Average True Range',
                            borderColor: 'rgb(153, 102, 255)',
                            fill: false,
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'dd.MM.yyyy'
                            }
                        }
                    }
                }
            });
        }
    }

    function updateCharts(days) {
        if (!stockData || !stockData.price_data || stockData.price_data.length === 0) {
            console.error('Keine Daten zum Aktualisieren der Charts verfügbar');
            return;
        }

        try {
            // Die neuesten Daten sollten am Ende des Arrays sein
            const reversedData = [...stockData.price_data].reverse();

            // Debug-Ausgabe der Daten
            console.log('Originaldaten:', stockData.price_data.length, 'Datenpunkte');
            console.log('Erster Datenpunkt:', new Date(stockData.price_data[0].date), stockData.price_data[0].close_price);
            console.log('Letzter Datenpunkt:', new Date(stockData.price_data[stockData.price_data.length-1].date), stockData.price_data[stockData.price_data.length-1].close_price);

            // Zeitraum berechnen
            const endDate = new Date(reversedData[0].date);
            const startDate = new Date(endDate);
            startDate.setDate(endDate.getDate() - days);

            console.log('Zeitraum:', startDate, 'bis', endDate);

            // Daten nach Datum filtern
            const filteredData = reversedData.filter(d => {
                const date = new Date(d.date);
                return date >= startDate && date <= endDate;
            });

            // Sicherstellen, dass nach Datum sortiert ist (aufsteigend)
            filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // Sicherstellen, dass der aktuelle Preis immer angezeigt wird, wenn Live-Daten aktiviert sind
            if (document.getElementById('use-live-data').checked && stockData.current_price) {
                // Prüfen, ob der letzte Datenpunkt der aktuelle Preis ist
                const lastPoint = filteredData[filteredData.length - 1];
                const lastPrice = lastPoint ? lastPoint.close_price : 0;

                console.log('Letzter Preis in gefilterten Daten:', lastPrice);
                console.log('Aktueller Preis:', stockData.current_price);

                // Wenn der letzte Preis nicht der aktuelle Preis ist, füge den aktuellen Preis hinzu
                if (Math.abs(lastPrice - stockData.current_price) > 0.01) {
                    console.log('Füge aktuellen Preis zu den Chartdaten hinzu');

                    // Aktuelles Datum für den neuen Datenpunkt
                    const now = new Date();

                    // Neuen Datenpunkt mit aktuellem Preis erstellen
                    const currentPricePoint = {
                        date: now.toISOString(),
                        open_price: stockData.current_price,
                        high_price: stockData.current_price,
                        low_price: stockData.current_price,
                        close_price: stockData.current_price,
                        volume: 0
                    };

                    // Zum gefilterten Array hinzufügen
                    filteredData.push(currentPricePoint);

                    // Neu sortieren, um sicherzustellen, dass die Daten in der richtigen Reihenfolge sind
                    filteredData.sort((a, b) => new Date(a.date) - new Date(b.date));
                }
            }

            console.log(`Gefilterte Daten für ${days} Tage:`, filteredData.length);

            if (filteredData.length === 0) {
                console.warn('Keine gefilterten Daten verfügbar');
                return;
            }

            // Daten für die Charts vorbereiten
            const chartDates = filteredData.map(d => new Date(d.date));
            const prices = filteredData.map(d => d.close_price);

            // Preischart aktualisieren
            if (priceChart) {
                priceChart.data.datasets[0].data = filteredData.map(d => ({
                    x: new Date(d.date),
                    y: d.close_price
                }));
                priceChart.update();
            }

            // RSI-Chart aktualisieren
            if (rsiChart && stockData.indicators && stockData.indicators.rsi) {
                // Wir müssen die Indikator-Daten an die gefilterten Preisdaten anpassen
                const indicatorLength = stockData.indicators.rsi.length;
                const priceLength = stockData.price_data.length;

                // Offset berechnen, wenn die Arrays unterschiedliche Längen haben
                const offset = Math.max(0, priceLength - indicatorLength);

                // Gefilterte Indizes bestimmen
                const filteredIndices = filteredData.map(d => {
                    return stockData.price_data.findIndex(p => p.date === d.date);
                }).filter(idx => idx !== -1);

                // RSI-Daten entsprechend extrahieren
                const rsiData = filteredIndices.map(idx => {
                    const adjustedIdx = idx - offset;
                    return adjustedIdx >= 0 && adjustedIdx < stockData.indicators.rsi.length
                        ? stockData.indicators.rsi[adjustedIdx]
                        : null;
                }).filter(d => d !== null);

                // Chart aktualisieren, wenn Daten vorhanden sind
                if (rsiData.length > 0) {
                    rsiChart.data.datasets[0].data = rsiData.map((rsi, i) => ({
                        x: chartDates[i],
                        y: rsi
                    }));
                    rsiChart.update();
                }
            }

            // MACD-Chart aktualisieren (ähnliche Logik wie beim RSI)
            if (macdChart && stockData.indicators &&
                stockData.indicators.macd &&
                stockData.indicators.macd_signal &&
                stockData.indicators.macd_histogram) {

                // Dieselbe Logik für Offset und gefilterte Indizes wie beim RSI
                const indicatorLength = stockData.indicators.macd.length;
                const priceLength = stockData.price_data.length;
                const offset = Math.max(0, priceLength - indicatorLength);

                const filteredIndices = filteredData.map(d => {
                    return stockData.price_data.findIndex(p => p.date === d.date);
                }).filter(idx => idx !== -1);

                // MACD-Daten extrahieren
                const macdData = [], macdSignalData = [], macdHistData = [];

                filteredIndices.forEach(idx => {
                    const adjustedIdx = idx - offset;
                    if (adjustedIdx >= 0 && adjustedIdx < stockData.indicators.macd.length) {
                        macdData.push(stockData.indicators.macd[adjustedIdx]);
                        macdSignalData.push(stockData.indicators.macd_signal[adjustedIdx]);
                        macdHistData.push(stockData.indicators.macd_histogram[adjustedIdx]);
                    }
                });

                // Chart aktualisieren, wenn Daten vorhanden sind
                if (macdData.length > 0) {
                    macdChart.data.datasets[0].data = macdHistData.map((hist, i) => ({
                        x: chartDates[i],
                        y: hist
                    }));
                    macdChart.data.datasets[1].data = macdData.map((macd, i) => ({
                        x: chartDates[i],
                        y: macd
                    }));
                    macdChart.data.datasets[2].data = macdSignalData.map((signal, i) => ({
                        x: chartDates[i],
                        y: signal
                    }));
                    macdChart.update();
                }
            }

            // Weitere Charts aktualisieren...
            // (Folgt dem gleichen Muster wie RSI und MACD)

            // Stochastic Chart
            if (stochasticChart && stockData.indicators &&
                stockData.indicators.stoch_k &&
                stockData.indicators.stoch_d) {

                const indicatorLength = stockData.indicators.stoch_k.length;
                const priceLength = stockData.price_data.length;
                const offset = Math.max(0, priceLength - indicatorLength);

                const filteredIndices = filteredData.map(d => {
                    return stockData.price_data.findIndex(p => p.date === d.date);
                }).filter(idx => idx !== -1);

                const kData = [], dData = [];

                filteredIndices.forEach(idx => {
                    const adjustedIdx = idx - offset;
                    if (adjustedIdx >= 0 && adjustedIdx < stockData.indicators.stoch_k.length) {
                        kData.push(stockData.indicators.stoch_k[adjustedIdx]);
                        dData.push(stockData.indicators.stoch_d[adjustedIdx]);
                    }
                });

                if (kData.length > 0) {
                    stochasticChart.data.datasets[0].data = kData.map((k, i) => ({
                        x: chartDates[i],
                        y: k
                    }));
                    stochasticChart.data.datasets[1].data = dData.map((d, i) => ({
                        x: chartDates[i],
                        y: d
                    }));
                    stochasticChart.update();
                }
            }
            // Bolesche Flagge, um zu prüfen, ob die Indikatoren in den API-Daten vorhanden sind
            console.log("Verfügbare Indikatoren:", Object.keys(stockData.indicators));

            // ROC Chart (Rate of Change)
            const rocCtx = document.getElementById('roc-chart');
            if (rocCtx) {
                if (!window.rocChart) {
                    // ROC Chart initialisieren, falls noch nicht geschehen
                    window.rocChart = new Chart(rocCtx.getContext('2d'), {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Rate of Change (14)',
                                    borderColor: 'rgb(75, 192, 192)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    data: []
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        tooltipFormat: 'dd.MM.yyyy'
                                    }
                                }
                            },
                            plugins: {
                                annotation: {
                                    annotations: {
                                        zeroline: {
                                            type: 'line',
                                            yMin: 0,
                                            yMax: 0,
                                            borderColor: 'rgba(0, 0, 0, 0.5)',
                                            borderWidth: 1,
                                            borderDash: [5, 5]
                                        }
                                    }
                                }
                            }
                        }
                    });
                }

                // ROC Werte berechnen, falls nicht in API vorhanden
                if (!stockData.indicators.roc && filteredData.length > 14) {
                    const rocPeriod = 14;
                    const rocValues = [];

                    for (let i = 0; i < filteredData.length; i++) {
                        if (i >= rocPeriod) {
                            const currentPrice = filteredData[i].close_price;
                            const oldPrice = filteredData[i - rocPeriod].close_price;
                            const roc = ((currentPrice - oldPrice) / oldPrice) * 100;
                            rocValues.push({
                                x: new Date(filteredData[i].date),
                                y: roc
                            });
                        } else {
                            rocValues.push({
                                x: new Date(filteredData[i].date),
                                y: null
                            });
                        }
                    }

                    window.rocChart.data.datasets[0].data = rocValues;
                    window.rocChart.update();
                } else if (stockData.indicators.roc) {
                    // ROC aus API verwenden, falls vorhanden
                    const indicatorLength = stockData.indicators.roc.length;
                    const priceLength = stockData.price_data.length;
                    const offset = Math.max(0, priceLength - indicatorLength);

                    const filteredIndices = filteredData.map(d => {
                        return stockData.price_data.findIndex(p => p.date === d.date);
                    }).filter(idx => idx !== -1);

                    const rocData = [];

                    filteredIndices.forEach(idx => {
                        const adjustedIdx = idx - offset;
                        if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                            rocData.push({
                                x: chartDates[filteredIndices.indexOf(idx)],
                                y: stockData.indicators.roc[adjustedIdx]
                            });
                        }
                    });

                    window.rocChart.data.datasets[0].data = rocData;
                    window.rocChart.update();
                }
            }

            // SMA Chart
            if (smaChart && stockData.indicators) {
                // Sicherstellen, dass die Preisdaten verfügbar sind
                const priceData = filteredData.map(d => ({
                    x: new Date(d.date),
                    y: d.close_price
                }));

                // Preisdaten setzen
                smaChart.data.datasets[0].data = priceData;

                // SMA-Indikatoren setzen
                const smaTypes = ['sma_20', 'sma_50', 'sma_200'];
                smaTypes.forEach((smaType, index) => {
                    if (!stockData.indicators[smaType]) return;

                    const indicatorLength = stockData.indicators[smaType].length;
                    const priceLength = stockData.price_data.length;
                    const offset = Math.max(0, priceLength - indicatorLength);

                    const filteredIndices = filteredData.map(d => {
                        return stockData.price_data.findIndex(p => p.date === d.date);
                    }).filter(idx => idx !== -1);

                    const smaData = [];

                    filteredIndices.forEach(idx => {
                        const adjustedIdx = idx - offset;
                        if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                            smaData.push({
                                x: new Date(filteredData[filteredIndices.indexOf(idx)].date),
                                y: stockData.indicators[smaType][adjustedIdx]
                            });
                        }
                    });

                    smaChart.data.datasets[index + 1].data = smaData;
                });

                smaChart.update();
            }

            // Bollinger Bands Chart
            if (bollingerChart && stockData.indicators) {
                // Preisdaten setzen
                const priceData = filteredData.map(d => ({
                    x: new Date(d.date),
                    y: d.close_price
                }));

                bollingerChart.data.datasets[0].data = priceData;

                // Bollinger Indikatoren setzen
                const bollingerTypes = ['sma_20', 'bollinger_upper', 'bollinger_lower'];
                bollingerTypes.forEach((indicator, index) => {
                    if (!stockData.indicators[indicator]) return;

                    const indicatorLength = stockData.indicators[indicator].length;
                    const priceLength = stockData.price_data.length;
                    const offset = Math.max(0, priceLength - indicatorLength);

                    const filteredIndices = filteredData.map(d => {
                        return stockData.price_data.findIndex(p => p.date === d.date);
                    }).filter(idx => idx !== -1);

                    const indicatorData = [];

                    filteredIndices.forEach(idx => {
                        const adjustedIdx = idx - offset;
                        if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                            indicatorData.push({
                                x: new Date(filteredData[filteredIndices.indexOf(idx)].date),
                                y: stockData.indicators[indicator][adjustedIdx]
                            });
                        }
                    });

                    bollingerChart.data.datasets[index + 1].data = indicatorData;
                });

                bollingerChart.update();
            }

            // Volume Chart
            if (volumeChart && filteredData.length > 0) {
                volumeChart.data.datasets[0].data = filteredData.map(d => ({
                    x: new Date(d.date),
                    y: d.volume
                }));
                volumeChart.update();
            }

            // OBV Chart
            if (obvChart && stockData.indicators && stockData.indicators.obv) {
                const indicatorLength = stockData.indicators.obv.length;
                const priceLength = stockData.price_data.length;
                const offset = Math.max(0, priceLength - indicatorLength);

                const filteredIndices = filteredData.map(d => {
                    return stockData.price_data.findIndex(p => p.date === d.date);
                }).filter(idx => idx !== -1);

                const obvData = [];

                filteredIndices.forEach(idx => {
                    const adjustedIdx = idx - offset;
                    if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                        obvData.push(stockData.indicators.obv[adjustedIdx]);
                    } else {
                        obvData.push(null);
                    }
                });

                if (obvData.length > 0) {
                    obvChart.data.datasets[0].data = obvData.map((value, i) => ({
                        x: chartDates[i],
                        y: value
                    }));
                    obvChart.update();
                }
            }

            // ATR Chart
            if (atrChart && stockData.indicators && stockData.indicators.atr) {
                const indicatorLength = stockData.indicators.atr.length;
                const priceLength = stockData.price_data.length;
                const offset = Math.max(0, priceLength - indicatorLength);

                const filteredIndices = filteredData.map(d => {
                    return stockData.price_data.findIndex(p => p.date === d.date);
                }).filter(idx => idx !== -1);

                const atrData = [];

                filteredIndices.forEach(idx => {
                    const adjustedIdx = idx - offset;
                    if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                        atrData.push(stockData.indicators.atr[adjustedIdx]);
                    } else {
                        atrData.push(null);
                    }
                });

                if (atrData.length > 0) {
                    atrChart.data.datasets[0].data = atrData.map((value, i) => ({
                        x: chartDates[i],
                        y: value
                    }));
                    atrChart.update();
                }
            }

            // ADX Chart
            const adxCtx = document.getElementById('adx-chart');
            if (adxCtx && stockData.indicators && stockData.indicators.adx) {
                if (!window.adxChart) {
                    // Initialisieren, falls noch nicht geschehen
                    window.adxChart = new Chart(adxCtx.getContext('2d'), {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'ADX',
                                    borderColor: 'rgb(153, 102, 255)',
                                    fill: false,
                                    data: []
                                },
                                {
                                    label: '+DI',
                                    borderColor: 'rgb(75, 192, 192)',
                                    fill: false,
                                    data: []
                                },
                                {
                                    label: '-DI',
                                    borderColor: 'rgb(255, 99, 132)',
                                    fill: false,
                                    data: []
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        tooltipFormat: 'dd.MM.yyyy'
                                    }
                                },
                                y: {
                                    min: 0,
                                    max: 100
                                }
                            }
                        }
                    });
                }

                const indicatorsMappings = [
                    {data: stockData.indicators.adx, index: 0},
                    {data: stockData.indicators['+di'], index: 1},
                    {data: stockData.indicators['-di'], index: 2}
                ];

                indicatorsMappings.forEach(indicator => {
                    if (!indicator.data) return;

                    const indicatorLength = indicator.data.length;
                    const priceLength = stockData.price_data.length;
                    const offset = Math.max(0, priceLength - indicatorLength);

                    const filteredIndices = filteredData.map(d => {
                        return stockData.price_data.findIndex(p => p.date === d.date);
                    }).filter(idx => idx !== -1);

                    const chartData = [];

                    filteredIndices.forEach(idx => {
                        const adjustedIdx = idx - offset;
                        if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                            chartData.push(indicator.data[adjustedIdx]);
                        } else {
                            chartData.push(null);
                        }
                    });

                    if (chartData.length > 0) {
                        window.adxChart.data.datasets[indicator.index].data = chartData.map((value, i) => ({
                            x: chartDates[i],
                            y: value
                        }));
                    }
                });

                window.adxChart.update();
            }

            // Ichimoku Cloud Chart
            const ichimokuCtx = document.getElementById('ichimoku-chart');
            if (ichimokuCtx && stockData.indicators) {
                const hasIchimokuData = stockData.indicators.tenkan_sen ||
                    stockData.indicators.kijun_sen ||
                    stockData.indicators.senkou_span_a ||
                    stockData.indicators.senkou_span_b;

                if (hasIchimokuData && !window.ichimokuChart) {
                    // Initialisieren, falls noch nicht geschehen
                    window.ichimokuChart = new Chart(ichimokuCtx.getContext('2d'), {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Preis',
                                    borderColor: 'rgb(0, 0, 0)',
                                    fill: false,
                                    order: 1,
                                    data: []
                                },
                                {
                                    label: 'Tenkan-sen',
                                    borderColor: 'rgb(255, 99, 132)',
                                    fill: false,
                                    order: 2,
                                    data: []
                                },
                                {
                                    label: 'Kijun-sen',
                                    borderColor: 'rgb(54, 162, 235)',
                                    fill: false,
                                    order: 3,
                                    data: []
                                },
                                {
                                    label: 'Senkou Span A',
                                    borderColor: 'rgba(75, 192, 192, 0.7)',
                                    fill: '+1',
                                    order: 4,
                                    data: []
                                },
                                {
                                    label: 'Senkou Span B',
                                    borderColor: 'rgba(255, 159, 64, 0.7)',
                                    backgroundColor: 'rgba(234, 234, 234, 0.3)',
                                    fill: '-1',
                                    order: 5,
                                    data: []
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        tooltipFormat: 'dd.MM.yyyy'
                                    }
                                }
                            }
                        }
                    });
                }

                if (window.ichimokuChart) {
                    // Preisdaten
                    window.ichimokuChart.data.datasets[0].data = filteredData.map(d => ({
                        x: new Date(d.date),
                        y: d.close_price
                    }));

                    // Ichimoku-Komponenten
                    const ichimokuComponents = [
                        {key: 'tenkan_sen', index: 1},
                        {key: 'kijun_sen', index: 2},
                        {key: 'senkou_span_a', index: 3},
                        {key: 'senkou_span_b', index: 4}
                    ];

                    ichimokuComponents.forEach(component => {
                        if (!stockData.indicators[component.key]) return;

                        const indicatorLength = stockData.indicators[component.key].length;
                        const priceLength = stockData.price_data.length;
                        const offset = Math.max(0, priceLength - indicatorLength);

                        const filteredIndices = filteredData.map(d => {
                            return stockData.price_data.findIndex(p => p.date === d.date);
                        }).filter(idx => idx !== -1);

                        const componentData = [];

                        filteredIndices.forEach(idx => {
                            const adjustedIdx = idx - offset;
                            if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                                componentData.push(stockData.indicators[component.key][adjustedIdx]);
                            } else {
                                componentData.push(null);
                            }
                        });

                        if (componentData.length > 0) {
                            window.ichimokuChart.data.datasets[component.index].data = componentData.map((value, i) => ({
                                x: chartDates[i],
                                y: value
                            }));
                        }
                    });

                    window.ichimokuChart.update();
                }
            }

            // PSAR Chart
            const psarCtx = document.getElementById('psar-chart');
            if (psarCtx && stockData.indicators && stockData.indicators.psar) {
                if (!window.psarChart) {
                    // Initialisieren, falls noch nicht geschehen
                    window.psarChart = new Chart(psarCtx.getContext('2d'), {
                        type: 'line',
                        data: {
                            datasets: [
                                {
                                    label: 'Preis',
                                    borderColor: 'rgb(54, 162, 235)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    order: 1,
                                    data: []
                                },
                                {
                                    label: 'PSAR',
                                    borderColor: 'rgb(255, 99, 132)',
                                    pointStyle: 'rectRot',
                                    pointRadius: 4,
                                    showLine: false,
                                    order: 2,
                                    data: []
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        tooltipFormat: 'dd.MM.yyyy'
                                    }
                                }
                            }
                        }
                    });
                }

                if (window.psarChart) {
                    // Preisdaten aktualisieren
                    window.psarChart.data.datasets[0].data = filteredData.map(d => ({
                        x: new Date(d.date),
                        y: d.close_price
                    }));

                    // PSAR-Daten aktualisieren
                    const indicatorLength = stockData.indicators.psar.length;
                    const priceLength = stockData.price_data.length;
                    const offset = Math.max(0, priceLength - indicatorLength);

                    const filteredIndices = filteredData.map(d => {
                        return stockData.price_data.findIndex(p => p.date === d.date);
                    }).filter(idx => idx !== -1);

                    const psarData = [];

                    filteredIndices.forEach(idx => {
                        const adjustedIdx = idx - offset;
                        if (adjustedIdx >= 0 && adjustedIdx < indicatorLength) {
                            psarData.push(stockData.indicators.psar[adjustedIdx]);
                        } else {
                            psarData.push(null);
                        }
                    });

                    if (psarData.length > 0) {
                        window.psarChart.data.datasets[1].data = psarData.map((value, i) => ({
                            x: chartDates[i],
                            y: value
                        }));
                    }

                    window.psarChart.update();
                }
            }

        } catch (error) {
            console.error('Fehler beim Aktualisieren der Charts:', error);
        }
        // ML-Vorhersage generieren
        const generateMlButton = document.getElementById('generate-ml-prediction');
        if (generateMlButton) {
            generateMlButton.addEventListener('click', function () {
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Generiere...';

                fetch(`/ml/predict/${symbol}/`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            // Seite neu laden, um die neue Vorhersage anzuzeigen
                            window.location.reload();
                        } else {
                            alert(`Fehler: ${data.message || 'Konnte keine ML-Vorhersage generieren'}`);
                            this.disabled = false;
                            this.innerHTML = '<i class="bi bi-lightning"></i> ML-Vorhersage generieren';
                        }
                    })
                    .catch(error => {
                        alert(`Fehler: ${error.message}`);
                        this.disabled = false;
                        this.innerHTML = '<i class="bi bi-lightning"></i> ML-Vorhersage generieren';
                    });
            });
        }
    }
});
</script>
{% endblock %}
